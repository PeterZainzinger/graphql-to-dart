// manage inheritence with a "Data" layer to avoid typing issues
class {{ className }}Data {{#if hasFragmentsSpread}}{{ classExtends fragmentsSpread }}{{/if}} {
  {{#each fields}}{{#if type}}{{#if name}}
  {{#if description }}{{ multilineComment description }}
  {{/if}}
  {{ resolveType type
      (takeFirst contextName ../contextName)
      (takeFirst contextModels ../contextModels)
      @root.config.scalars
      @root.config.replaceTypes
      isArray
  }} {{name}};
  {{~/if}}{{/if}}{{/each}}

  static C copyInto<C extends {{className}}Data>(C source, C into) {
    {{~#each fields~}}{{#if name}}
    into.{{name}} = source.{{name}};
    {{~/if}}{{/each}}
    return into;
  }

}

@JsonSerializable()
class {{ className }} extends {{ className }}Data {

  // we still need to copy all the fields though :-/
  {{#each fields}}{{#if type}}{{#if name}}
  {{#if description }}{{ multilineComment description }}
  {{/if}}
  {{ resolveType type
      (takeFirst contextName ../contextName)
      (takeFirst contextModels ../contextModels)
      @root.config.scalars
      @root.config.replaceTypes
      isArray
  }} {{name}};
  {{~/if}}{{/if}}{{/each}}

  {{className}}(
  {{~#if fields.length~}}
  {
    {{#each fields}}{{#if name}}
    {{~#if isRequired}}@required {{/if}}this.{{name}},
    {{/if}}{{/each}}
  }
  {{~/if}});


  C copyInto<C extends {{className}}Data>(C into) {
    {{~#each fields~}}{{#if name}}
    into.{{name}} = this.{{name}};
    {{~/if}}{{/each}}
    return into;
  }

  {{className}} copy() {
     return {{className}}(
      {{~#each fields~}}{{#if name}}
      {{name}}: this.{{name}},
      {{~/if}}{{/each}}
    );
  }

  factory {{className}}.fromJson(Map<String, dynamic> json) => _${{className}}FromJson(json);
  Map<String, dynamic> toJson() => _${{className}}ToJson(this);
}
